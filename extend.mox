private
  open Lex
  open Parse
  open Ext
in

# Some utility functions
fun first(a,b) = a
fun second(a,b) = b

fun testParse(parser) =
  # env, stream, hardk, softk, ok
  parser(None, None, first, first, second)


# Let's make writing parsers a bit easier, shall we?
# First, a syntax for Parse.pure:
#     @x == Parse.pure(x)
hide val parsePure =
  # unhygienic :(
  let fun f(x) = `e(Parse.pure(~x))
  # NB. precedence 12 prohibits even function application
  in map(Quasi.lift(f), exprAt(12))

extend Exprs with
  Hash.single(TSYM("@"), parsePure)

# Now a syntax for Parse.map:
#     f@ ~> Parse.lift(f)
#     f@(x,y,z) ~> Parse.lift(f)(x,y,z) = Parse.map(f,x,y,z)
hide fun parseMap(funcExpr) =
  let fun make(f) = `e(Parse.lift(~f))
  in pure(Quasi.map(make, funcExpr))

hide val extMap =
  Hash.put(symbol("precedence"), 11,
    Hash.single(symbol("parse"), parseMap))

extend InfixExprs with
  Hash.single(TSYM("@"), extMap)

# Now Parse.bind:
#     (bind x = expr in xyzzy) = Parse.bind(expr, \(x) xyzzy)
hide val parseBind =
  let fun make(pat, exp, body) = `e(Parse.bind(~exp, \(~pat) ~body))
  # this Quasi.lift(foo)@(...) pattern keeps coming up a lot
  in Quasi.lift(make)@(pat, second@(equals, expr), second@(keyword("in"), expr))

extend Exprs with Hash.single(TID("bind"), parseBind)


# Now we do the same for Quasi, only with ^ instead of @
hide val parseQPure = Quasi.lift(\(x) `e(Quasi.pure(~x)))@(exprAt(12))
extend Exprs with Hash.single(TSYM("^"), parseQPure)

hide fun parseQMap(funcExpr) =
  let fun make(f) = `e(Quasi.lift(~f))
  in pure(Quasi.map(make, funcExpr))

extend InfixExprs with
  Hash.single(TSYM("^"),
    Hash.put(symbol("precedence"), 11,
      Hash.single(symbol("parse"), parseQMap)))


# List expressions.
# TODO: list comprehensions?
hide val parseList =
  let
    fun single(x) = `e(List.list(~x))
    val elem = choice(single^ @(expr), second@(keysym(".."), expr))
    fun make(as) = `e(List.append(~..as))
  in Quasi.lift(make)@(listishQ(elem))

extend Exprs with Hash.single(TLBRACK, first@(parseList, rbrack))


# Pattern-matching on lists.
# hide val listPat =
#   let
    
#   in Quasi.lift(make)@(qIfy(\ (x) beginSepBy(x, comma))(pat),
#                        optionMaybe(second@(comma, first@(pat, keysym("..")))))
# extend Pats with Hash.single(TLBRACK, first@(listPat, rbrack))
