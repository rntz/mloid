private
  open Lex
  open Parse
  open Ext
in

# Some utility functions
fun first(a,b) = a
fun second(a,b) = b

fun testParse(parser) =
  # env, stream, hardk, softk, ok
  parser(None, None, first, first, second)

# precedence 12 prohibits all infix operators, even function application
val headExpr = exprAt(12)
val callExpr = exprAt(11) # prohibits all except function application


# Let's make writing parsers a bit easier, shall we?
# First, a syntax for Parse.pure:
#     @x == Parse.pure(x)
hide val parsePure =
  # unhygienic :(
  let fun f(x) = `e(Parse.pure(~x))
  in map(Quasi.lift(f), callExpr)

extend Exprs = Hash.single(TSYM("@"), parsePure)

# Now a syntax for Parse.map:
#     f@ ~> Parse.lift(f)
#     f@(x,y,z) ~> Parse.lift(f)(x,y,z) = Parse.map(f,x,y,z)
hide fun parseMap(funcExpr) =
  let fun make(f) = `e(Parse.lift(~f))
  in pure(Quasi.map(make, funcExpr))

hide val extMap =
  Hash.put(symbol("precedence"), 11,
    Hash.single(symbol("parse"), parseMap))

extend InfixExprs = Hash.single(TSYM("@"), extMap)

# Now Parse.bind:
#     (bind x = expr in xyzzy) = Parse.bind(expr, \(x) xyzzy)
hide val parseBind =
  let fun make(pat, exp, body) = `e(Parse.bind(~exp, \(~pat) ~body))
  # this Quasi.lift(foo)@(...) pattern keeps coming up a lot
  in Quasi.lift(make)@(pat, second@(equals, expr), second@(keyword("in"), expr))

extend Exprs = Hash.single(TID("bind"), parseBind)


# Now we do the same for Quasi, only = ^ instead of @
hide val parseQPure = Quasi.lift(\(x) `e(Quasi.pure(~x)))@(callExpr)
extend Exprs = Hash.single(TSYM("^"), parseQPure)

hide fun parseQMap(funcExpr) =
  let fun make(f) = `e(Quasi.lift(~f))
  in pure(Quasi.map(make, funcExpr))

extend InfixExprs =
  Hash.single(TSYM("^"),
    Hash.put(symbol("precedence"), 11,
      Hash.single(symbol("parse"), parseQMap)))


# List expressions.
# TODO: list comprehensions?
hide val parseList =
  let
    fun single(x) = `e(List.list(~x))
    val elem = choice(single^ @(expr), second@(keysym(".."), expr))
    fun make(as) = `e(List.append(~..as))
  in Quasi.lift(make)@(listishQ(elem))

extend Exprs = Hash.single(TLBRACK, first@(parseList, rbrack))


# Creating hashes
hide val parseHash =
  let fun lit(x) = ^AST.exprLit(x)
      val field = try(first@(lit@(varId), equals))
      fun muddle(a,b) = `e([[~a, ~b]])
      val elem = muddle^ @(choice(field, first@(expr, colon)), expr)
      fun make(as) = `e(Hash.fromList([~..as]))
  in make^ @(listishQ(elem))

extend Exprs = Hash.single(TLBRACE, first@(parseHash, rbrace))

# val infixOp

# Dot syntax for accessing "fields" of hashes
#    a.foo ~> Hash.get(symbol("foo"), a)

hide fun parseHashGet(hashExpr) =
  let fun make(hash, field) = `e(Hash.get(~(AST.exprLit(field)), ~hash))
  in make^ @(@hashExpr, Quasi.pure@(varId))

extend InfixExprs = { TSYM("."): { precedence = 10, parse = parseHashGet } }


# Convenience for infix operators
tag L
tag R

fun infix(parseAt) = \(prec,assoc,make)
  { precedence = prec
  , parse = \ (leftExpr)
      make@(@leftExpr, parseAt(prec + (case assoc | R -> 0 | L -> 1))) }

fun infixExpr(prec,assoc,make) = infix(exprAt)(prec,assoc,make^)


# x >> y = bind _ = x in y
extend InfixExprs =
  { TSYM(">>"): infixExpr(1, R, \(l,r) `e(bind _ = ~l in ~r))
  , TSYM("<*"): infixExpr(4, L, \(l,r) `e((\(x,_) x)@(~l, ~r))) }


# An utterly hackish quote-form for s-expressions.
hide val parseAtom = choice(literal, anyId)

hide
fun parseSexp(env,str,hardk,softk,ok) =
  (choice(Quasi.pure@(parseAtom),
          second@(keysym("~"), unquoExpr),
          Quasi.seq@(parens(many(parseSexp)))))
    (env,str,hardk,softk,ok)

extend QuoteForms = { TID("s"): parseSexp }


# Pattern-matching on lists.
# what a hack.
hide val nilPat = {
  sexp = \() [],
  resolveExt = {},
  idents = [],
  compile = \(env, subj, onSuc, onFail)
              `s((if (~(symbol("null?")) ~subj) ~onSuc ~onFail))
}

hide fun consPat(a, b) = {
  sexp = \() `s((cons ~(a.sexp()) ~(b.sexp()))),
  resolveExt = Env.join(a.resolveExt, b.resolveExt),
  idents = List.append(a.idents, b.idents),
  compile = \(env, subj, onSuc, onFail)
              `s((if (~(symbol("pair?")) ~subj)
                    ~(a.compile(env, `s((car ~subj)),
                        b.compile(env, `s((cdr ~subj)), onSuc, onFail),
                        onFail))
                    ~onFail))
}

hide val listPat =
  let fun make(elems, tail) =
        List.foldr(consPat, fromMaybe(tail, nilPat), elems)
  in make^ @(listishQ(pat),
             # FIXME: allows duplicate comma
             option(^None, second@(optional(comma),
               option(^None, second@(keysym(".."), Just^ @(pat))))))

extend Pats = {TLBRACK: first@(listPat, rbrack)}


# Dictionary utilies
extend InfixExprs =
  { TID("with"): infixExpr(10, L, \(l,r) `e(Hash.union(~l, ~r))) }


# Parser-specific eta-expansion
# TODO: make non-parser-specific
hide val parseEta =
  let fun make(x) = `e(\(env,str,hardk,softk,ok) ~x(env,str,hardk,softk,ok))
  in make^ @(expr)

extend Exprs = { TID("eta"): parseEta }
